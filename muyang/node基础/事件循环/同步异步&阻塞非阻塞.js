// a,b

// 同步异步指的是行为即两者之间的关系， 而阻塞非阻塞指的是状态即某一方
// $.ajax(url).succedd(() => {
//   ......
//   // to do something
// })
// 同步异步
// 如果是同步的话， 那么应该是客户端发起请求后， 一直等到serve处理请求完成后才返回继续执行后续的逻辑， 这样客户端和服务端之间就保持了同步的状态。

// 如果是异步的话， 那么应该是客户端发起请求后， 立即返回， 而请求可能还没有到达服务端或者请求正在处理， 当然在异步情况下， 客户端通常会注册事件来处理请求完成后的情况， 如上面的succeed函数。

// 阻塞非阻塞

// 首先需要明白一个概念， Js是单线程， 但是浏览器并不是， 事实上你的请求是浏览器的另一个线程在跑。

// 如果是阻塞的话， 那么该线程就会一直等到这个请求完成之后才能被释放用于其他请求。

// 如果是非阻塞的话， 那么该线程就可以发起请求后而不用等请求完成继续做其他事情。

// 异步IO操作

// 文件读取的方式是一次性全部读取， 当文件过大的时候， 一次性读取不仅缓慢， 而且影响用户体验， 那么怎么实现分步读取呢，

// 这就得使用到异步IO的操作， 像水流一样流出一段取得一段。

// 具体实现：

// 我们创建一个文件读取流， 先上代码

var fs = require("fs");

var data = ""; //声明一个空字符串来存读取的数据
var rs = fs.createReadStream("./a.txt");
var ws = fs.createWriteStream("b.txt"); //写入流

rs.setEncoding("utf-8");

//监听当有数据流入的时候
rs.on("data", function (chunc) {
  data += chunc; //将读取的数据拼接到data上。
  console.log(chunc,'========')
  console.log("..."); //读的过程中，我们打印三个点。
  ws.write(chunc, "utf-8"); //向文件写入东西
});

rs.on("end", function () {
  console.log("没有数据了")
  ws.end();
});